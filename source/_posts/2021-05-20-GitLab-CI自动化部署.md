---
title: GitLab-CI自动化部署
date: 2021-05-20 11:50:02
categories:
- [Git]
tags:
    - Git
---



## 一、概念介绍

### CI/CD概念
CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。CI/CD 主要针对的是在集成新代码时所引发的问题（“集成地狱”）。

具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。

借助CI/CD，开发人员可以对迭代的代码更新进行连续构建、测试和部署。此过程避免了频繁又繁琐的手动构建、部署过程，既节省了开发时间，同时减少了人工干预导致的各种异常情况。

<!-- more -->

### CI 持续集成 （Continuous Integration）
CI/CD 中的“CI”始终指持续集成，它属于开发人员的自动化流程。现代应用的开发往往会将代码存储在共享存储库中，开发人员每天要推送代码更改。那么对于每次向代码库的推送操作，可以创建一组脚本来自动化构建和测试代码更改，这些脚本有助于减少手动操作而引入错误的机会。这种做法就被称为“持续集成”。

成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享代码库中。该方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。

### CD 持续部署（Continuous Deployment）
持续部署是持续集成的下一步，代码构建完毕后，可以自动地将新版本部署上线，这样有利于快速迭代并交付产品。

### CD 持续交付（Continuous Delivery）
持续交付是持续集成的又一个步骤，与持续部署不同的时，需要人工干预才能出发变更的部署。


## 二、Gitlab CI/CD
Gitlab CI/CD（简称Gitlab-CI）是Gitlab官方提供的基于Gitlab的CI/CD服务，开发人员可以在项目仓库的根目录下创建.gitlab-ci.yml文件，并在其中定义CI/CD流程模板。这样在每次提交后，系统可以自动地执行构建、测试、检查等任务。

Gitlab-CI的配置非常简单，只需部署一个Runner程序，并完成Runner的注册即可完成一套CI/CD系统的搭建。并且Gitlab-CI的Runner程序由Go编写，因此部署Runner也很简单，尤其是用Docker部署！

这里先介绍一下Gitlab-CI中的一些名词概念：

#### Job

Job 为一个具体执行的任务，是 GitLab-CI 系统中可以独立控制并运行的最小单位，也是.gitlab-ci.yml文件中的最基本元素。

Job特征：
- 定义了约束条件，指出应当在什么条件下执行。
- job是顶级元素，job的名称可以自定义，并且必须包含`script`子句
- job的数量没有限制

Job示例：

{% codeblock lang:yml %}
job1:
  script: "execute-script-for-job1"

job2:
  script: "execute-script-for-job2" 
{% endcodeblock %} 
上面的示例是具有两个单独作业的最简单的配置，Job可以在代码库中直接执行代码或脚本。

在提交代码后，开发者可以针对特定的 commit 完成一个或多个 job，从而进行 CI/CD 操作。

#### Pipeline
Pipeline即任务管道，是CI/CD的顶级组件。在一个Pipeline中可以像流水线一样执行多个Job。Pipeline由Runner执行。

Pipeline包括：
- Job: 定义要做什么。例如编译或测试代码。
- Stage: 定义何时运行作业。例如在编译之后运行测试。

如果一个Stage中的所有Job都执行成功，则Pipeline将继续进行到下一个Stage。
如果某个Stage中的任何Job执行失败，则Pipeline不会执行下一个Stage，并提前结束。

#### Stage
一个Pipline中通常会分为几个阶段（Stage），将Job划分在不同的阶段进行顺序执行。

#### Pipeline示例

{% codeblock lang:yml %}
build-job:
  stage: build
  script:
    - echo "Hello, $GITLAB_USER_LOGIN!"

test-job1:
  stage: test
  script:
    - echo "This job tests something"

test-job2:
  stage: test
  script:
    - echo "This job tests something, but takes more time than test-job1."
    - echo "After the echo commands complete, it runs the sleep command for 20 seconds"
    - echo "which simulates a test that runs 20 seconds longer than test-job1"
    - sleep 20

deploy-prod:
  stage: deploy
  script:
    - echo "This job deploys something from the $CI_COMMIT_BRANCH branch." 
{% endcodeblock %} 
上面的配置对应到Gitlab-CI中进行可视化展示如下图：

{% img /images/gitlab_ci_flow.png  '"gitlab ci flow"' %}

#### Runner
在Gitlab-CI中，Runner可以理解为是一个在特定机器上根据.gitlab-ci.yml配置文件生成并运行Pipeline的程序。它从Gitlab获取CI作业，运行该作业，并将结果发送回Gitlab实例。

Runner有三种类型：
- Shared Runner: Gitlab中所有项目和组都可以使用的共享Runner。
- Group Runner: 可用于组中所有项目和子组的Runner。
- Specific Runner: 只能在指定项目中使用的Runner。


{% img /images/runner_types.png  '"gitlab runner types"' %}

#### Executor

Runner执行Pipeline是需要基于特定的平台（环境）的，这个平台（环境）就是Executor。我们在注册Runner时，程序会提示我们选择指定的平台类型，可供选择的有SSH、Shell、VirtualBox、Docker等等。

## 三、.gitlab-ci.yml流程配置详解

一个简单且完整的.gitlab-ci.yml配置文件如下：
{% codeblock lang:yml %}
before_script:
  - echo "starting build vul_crawling...."
  - echo $CI_COMMIT_TAG

stages:
  - build_docker_image

build_docker_images-job:
  stage: build_docker_image
  image: gitlab/dind
  services:
    - docker:dind
  script:
    - bash .deploy/build.sh -e ${CI_COMMIT_TAG%-*} -v ${CI_COMMIT_TAG#*-} -u $DOCKER_USER -p $DOCKER_PASSWORD
  only:
    - /(test|prod)-\d+\.\d+\.\d+$/
  tags:
    - sec_docker_runner

{% endcodeblock %}

通常一个.gitlab-ci.yml文件中会定义一个`stages`和若干个`job`, `stages`中定义了整个流程的各个阶段，而`job`则定义了具体执行的任务、任务所处阶段和一些约束条件。

下面对.gitlab-ci.yml中的关键字做简单介绍：

1. 不能被用于Job名称的保留关键字
- `image`: 使用的Docker镜像
- `services`: 使用的Docker服务的镜像
- `stages`: 定义流程的阶段
- `types`: `stages`的别名（不建议使用）
- `before_script`：在Job执行前执行的一组命令
- `after_script`: 在Job执行后执行的一组命令
- `variables`: 定义流程中的变量
- `cache`: 定义将被缓存的文件列表，后续任务可用
- `include`：包含其他的YAML文件

2. 定义Job的关键字
- `before_script`: 在Job执行前执行的一组命令
- `after_script`: 在Job执行后执行的一组命令
- `allow_failure`: 允许任务失败，任务失败不会导致pipeline失败
- `artifacts`: 指定依附于Job的文件和目录列表，在任务结束后，可以在gitlab UI上下载这些文件和目录
- `cache`: 定义将被缓存的文件列表，后续任务可用
- `coverage`: 定义给定作业的代码覆盖率设置
- `dependencies`: 定义job依赖关系，这样他们就可以互相传递artifacts
- `environment`: 定义此作业完成部署的环境名称
- `only`: 定义在哪些分支上创建Jobs
- `except`: 定义哪些分支不创建Jobs
- `extends`: 从其他job继承，字段会合并
- `image`:	指定job使用的Docker镜像
- `include`: 包含其他的YAML文件
- `inherit`: 控制全局定义的默认值和变量的继承关系
- `interruptible`: 设置一个新的pipeline运行时将取消正在运行的pipeline
- `needs`: 定义job的依赖关系，可以使job之间进行无序执行
- `retry`: 发生故障时可以自动重试作业的时间和次数
- `rules`:
- `script`: 运行程序执行的Shell脚本
- `secrets`:
- `services`: 使用Docker的服务映像
- `stage`: 定义工作阶段
- `tags`: 定义可以由包含哪些tag的Runner来执行Job
- `variables`: 在Job级别上定义Job变量
- `when`: 定义Job执行的时机

常用关键字详解：

1. `before_script`、`script`、`after_script`
`before_script`和`after_script`分别指在Job执行前和Job执行后执行的命令，可以定义在Job级别，也可以定义为顶级元素，定义为顶级元素将为每一个任务都执行相应阶段的脚本或命令。`script`只能在Job中定义，表示具体执行的任务内容。
{% codeblock lang:yml %}
default:
  before_script:
    - echo "Execute this script in all jobs that don't already have a before_script section."
  after_script:
    - echo "Execute this script in all jobs that don't already have an after_script section."

job1:
  script:
    - echo "This script executes first. When it completes, the global after_script executes."

job:
  before_script:
    - echo "Execute this script instead of the global before_script."
  script:
    - echo "This script executes first. When it completes, the job's `after_script` executes."
  after_script:
    - echo "Execute this script instead of the global after_script."
{% endcodeblock %}
2. `stages`

使用`stages`定义pipeline的工作阶段，同一stage中的job可以并行执行。

{% codeblock lang:yml %}
stages:
    - build
    - test
    - deploy
{% endcodeblock %}

3. `variables`

使用`variables`可以在.gitlab-ci.yml中定义变量，这些变量会被设置入任务执行环境，可以在job中使用。

变量除了可以在.gitlab-ci.yml中定义外，还可以在gitlab上定义，如图：

{% img /images/gitlab_ci_variables.png  '"gitlab_ci_variables"' %}

另外gitlab-CI还预定义了一些变量，可以直接在任务中使用，详见：https://docs.gitlab.com/ee/ci/variables/predefined_variables.html
{% codeblock lang:yml %}
  script:
    - bash .deploy/build.sh -e ${CI_COMMIT_TAG%-*} -v ${CI_COMMIT_TAG#*-} -u $DOCKER_USER -p $DOCKER_PASSWORD
{% endcodeblock %}

5. `only`、`except`
only和except约束了job在什么情况下会被创建，only定义了在哪些分支或标签上创建，except定义了job不会在哪些分支合标签上创建。
{% codeblock lang:yml %}
  only:
    - /(test|prod)-\d+\.\d+\.\d+$/
{% endcodeblock %}

6. `tags`
在注册Runner时，程序会提示Runner对应的tags。使用tags可以约束由对应tags的Runner来执行Job，如果没有tags对应的Runner可用，则任务不会被执行。

## 四、Gitlab-CI自动构建流程搭建实战

### 1.安装和运行Runner
1. 选择一台服务器作为部署Runner的机器（确保与部署Gitlab的机器能正常通讯）。
2. 选择Runner的安装方式。常用的Runner安装方式主要有两种：一是基于Docker镜像安装在容器中；二是下载二进制文件直接安装在服务器中。
3. 
#### 二进制文件安装
1. 针对服务器的系统下载对应的二进制文件
{% codeblock lang:shell %}
# Linux x86-64
sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64"

# Linux x86
sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386"

# Linux arm
sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm"

# Linux arm64
sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm64"

# Linux s390x
sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-s390x"
{% endcodeblock %}

2. 添加执行权限
{% codeblock lang:shell %}
sudo chmod +x /usr/local/bin/gitlab-runner
{% endcodeblock %}
3. 创建一个Gitlab-CI 用户
{% codeblock lang:shell %}
sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash
{% endcodeblock %}
4. 安装和运行
{% codeblock lang:shell %}
sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner
sudo gitlab-runner start
{% endcodeblock %}

#### 基于Docker镜像安装
1. 基于`gitlab/gitlab-runner:latest`镜像来启动Runner容器
{% codeblock lang:shell %}
docker run -d \
	--name gitlab-runner \
    --restart always \
    --privileged=true \ 
    -v /srv/gitlab-runner/config:/etc/gitlab-runner \ 
    -v /var/run/docker.sock:/var/run/docker.sock \
    gitlab/gitlab-runner:latest
{% endcodeblock %}
注意，这里将runner的配置目录挂载到宿主机文件系统，便于修改配置。同时把宿主机docker.sock挂载到容器中，是为了后面在容器中使用docker命令时（docker in docker）直接调用宿主机的Docker daemon。

### 2.注册Runner

#### 二进制安装
1. 运行注册命令
{% codeblock lang:shell %}
sudo gitlab-runner register
{% endcodeblock %}
2. 根据提示输入相应信息完成注册
- 输入Gitlab服务的URL
- 输入注册token
- 输入runner的描述信息
- 输入runner关联的标签，以逗号分隔
- 选择executor，runner的执行平台

#### Docker安装
1. 进入gitlab-runner容器执行注册
{% codeblock lang:shell %}
docker exec -it gitlab-runner gitlab-runner register
{% endcodeblock %}
2. 根据命令行提示输入相应信息完成注册。
- 输入Gitlab服务的URL
- 输入注册token。token在gitlabUI-settings-CI/CD-Runner-expand下
- 输入runner的描述信息
- 输入runner关联的标签，以逗号分隔
- 选择executor，runner的执行平台
- 输入默认的docker镜像（如果job中未指定执行的镜像，将使用默认的）

示例如下：

{% img /images/runner_register.png  '"runner_register"' %}

3. 修改刚注册成功的runner配置
配置文件路径：/etc/gitlab-runner/config.toml。将`privileged`选项改为`true`。不然在执行job的时候可能会遇到问题，参见：https://gitlab.com/gitlab-org/gitlab-runner/-/issues/1544

4. 重启runner容器

{% codeblock lang:shell %}
docker restart gitlab-runner
{% endcodeblock %}

### 3.添加.gitlab-ci.yml

在项目根目录下创建.gitlab-ci.yml文件，配置任务执行流程
例如：
{% codeblock lang:yml %}

before_script:
  - echo "starting build vul_crawling...."
  - echo $CI_COMMIT_TAG

stages:
  - build_docker_image

build_docker_images-job:
  stage: build_docker_image
  image: gitlab/dind
  services:
    - docker:dind
  script:
    - bash .deploy/build.sh -e ${CI_COMMIT_TAG%-*} -v ${CI_COMMIT_TAG#*-} -u $DOCKER_USER -p $DOCKER_PASSWORD
  only:
    - /(test|prod)-\d+\.\d+\.\d+$/
  tags:
    - sec_docker_runner

{% endcodeblock %}

### 4.添加自定义变量
在gitlab UI - Settings - CI/CD - Variables下添加自定义变量


### 5.流程测试
完成以上步骤后，Gitlab-Ci自动构建部署流程已配置完成。在上例中，当有分支或Tag名称类似`test-0.0.1`或`prod-0.0.1`时，系统将自动创建pipeline完成自动化构建部署。





