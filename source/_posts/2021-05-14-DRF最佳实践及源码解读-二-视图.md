---
title: DRF最佳实践及源码解读(二)--视图
date: 2020-04-18 14:13:48
categories:
- [Python, Web]
tags:
    - Django
    - Python
    - Restful
---

{% img /images/djangorestframework.png    '"DRF框架"' %}

## DRF视图类最佳实践

简单增删改查：`ModelViewSet`

增删：`CreateModelMixin` + `DestroyModelMixin` + `GenericViewSet`

复杂逻辑：`GenericViewSet` 或 `APIView` (多个路由的相同请求方法使用同一个视图类的时候，使用`GenericViewSet`)



<!-- more -->



### 视图类继承关系


{% img /images/drf_view_class.png    '"DRF视图类继承关系"' %}


### 视图类源码解读

#### django.views.generic.View

{% codeblock lang:python %}
# django原生CBV

from django.views.generic import View
# 对视图函数的装饰需要使用method_decorator
from django.utils.decorators import method_decorator

@method_decorator(uc_login_required(), name='dispatch')
class CheckERPView(View):
    """
    django原生CVB使用示例
    通过viewClass.as_view()返回包装后的视图函数，同时以闭包的方式将视图类封装进视图函数
    在View.dispatch()中通过对请求方法的判断将请求分发到具体的get/post/put/delete方法中
    """
    def get(self, request, *args, **kwargs):
        pass

    def post(self, request, *args, **kwargs)):
        pass
{% endcodeblock %}




#### rest_framework.views.APIView

{% codeblock lang:python %}

"""
DRF基础视图类
APIView是DRF提供的所有视图的基类继承自Django的View
APIVIew通过对dispatch方法的增强，主要实现了以下功能:
    1.initialize_request()对django的request进行封装，得到DRF的request
    2.视图方法可以返回DRF的Response
    3.任何APIException异常都会被捕获到，并且处理成合适的响应信息
    4.在dispatch()分发前，会对请求进行身份认证、权限检查、流量控制，相应的扩展通过类属性进行配置，可以在类中局部配置，也可以在配置文件中全局配置
"""

class APIView(View):

    # The following policies may be set at either globally, or per-view.
    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES
    parser_classes = api_settings.DEFAULT_PARSER_CLASSES
    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
    throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES
    content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS
    metadata_class = api_settings.DEFAULT_METADATA_CLASS
    versioning_class = api_settings.DEFAULT_VERSIONING_CLASS

    # Allow dependency injection of other settings to make testing easier.
    settings = api_settings

    # Mark the view as being included or excluded from schema generation.
    exclude_from_schema = False
    
    # Note: Views are made CSRF exempt from within `as_view` as to prevent
    # accidental removal of this exemption in cases where `dispatch` needs to
    # be overridden.
    
    def dispatch(self, request, *args, **kwargs):
        """
        `.dispatch()` is pretty much the same as Django's regular dispatch,
        but with extra hooks for startup, finalize, and exception handling.
        """
        self.args = args
        self.kwargs = kwargs
        request = self.initialize_request(request, *args, **kwargs)
        self.request = request
        self.headers = self.default_response_headers  # deprecate?

        try:
            self.initial(request, *args, **kwargs)

            # Get the appropriate handler method
            if request.method.lower() in self.http_method_names:
                handler = getattr(self, request.method.lower(),
                                  self.http_method_not_allowed)
            else:
                handler = self.http_method_not_allowed

            response = handler(request, *args, **kwargs)

        except Exception as exc:
            response = self.handle_exception(exc)

        self.response = self.finalize_response(request, response, *args, **kwargs)
        return self.response
    
{% endcodeblock %}


#### rest_framework.generics.GenericAPIView

{% codeblock lang:python %}
"""
PS:通常不直接使用
GenericAPIView继承自APIView
增加了对列表视图和详情视图的通用处理方法
    1.通过queryset配置查询集
    2.通过serializer_class配置序列化器
    3.通过pagination_class配置分页器
"""

class GenericAPIView(views.APIView):
    """
    Base class for all other generic views.
    """
    # You'll need to either set these attributes,
    # or override `get_queryset()`/`get_serializer_class()`.
    # If you are overriding a view method, it is important that you call
    # `get_queryset()` instead of accessing the `queryset` property directly,
    # as `queryset` will get evaluated only once, and those results are cached
    # for all subsequent requests.
    queryset = None
    serializer_class = None

    # If you want to use object lookups other than pk, set 'lookup_field'.
    # For more complex lookup requirements override `get_object()`.
    lookup_field = 'pk'
    lookup_url_kwarg = None

    # The filter backend classes to use for queryset filtering
    filter_backends = api_settings.DEFAULT_FILTER_BACKENDS

    # The style to use for queryset pagination.
    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS

    def get_queryset(self):
        queryset = self.queryset
        if isinstance(queryset, QuerySet):
            # Ensure queryset is re-evaluated on each request.
            queryset = queryset.all()
        return queryset

    def get_object(self):
        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}
        obj = get_object_or_404(queryset, **filter_kwargs)
        # May raise a permission denied
        self.check_object_permissions(self.request, obj)
        return obj

    def get_serializer(self, *args, **kwargs):
        serializer_class = self.get_serializer_class()
        kwargs['context'] = self.get_serializer_context()
        return serializer_class(*args, **kwargs)

    def get_serializer_class(self):
        return self.serializer_class

    def get_serializer_context(self):
        return {
            'request': self.request,
            'format': self.format_kwarg,
            'view': self
        }

    def filter_queryset(self, queryset):
        for backend in list(self.filter_backends):
            queryset = backend().filter_queryset(self.request, queryset, self)
        return queryset

    @property
    def paginator(self):
        if not hasattr(self, '_paginator'):
            if self.pagination_class is None:
                self._paginator = None
            else:
                self._paginator = self.pagination_class()
        return self._paginator

    def paginate_queryset(self, queryset):
        if self.paginator is None:
            return None
        return self.paginator.paginate_queryset(queryset, self.request, view=self)

    def get_paginated_response(self, data):
        assert self.paginator is not None
        return self.paginator.get_paginated_response(data)
{% endcodeblock %}


#### rest_framework.viewsets.GenericViewSet

{% codeblock lang:python %}
"""
继承自ViewSetMixin和GenericAPIView
基于ViewSetMixin对as_view()方法进行升级，实现了请求方法与方法名的自定义绑定
配置路由的时候传入请求方法与分发方法的对应关系：
    MyViewSet.as_view({'get': 'list', 'post': 'create'})
"""

class GenericViewSet(ViewSetMixin, generics.GenericAPIView):
    """
    The GenericViewSet class does not provide any actions by default,
    but does include the base set of generic view behavior, such as
    the `get_object` and `get_queryset` methods.
    """
    pass
    

class ViewSetMixin(object):
    """
    This is the magic.

    Overrides `.as_view()` so that it takes an `actions` keyword that performs
    the binding of HTTP methods to actions on the Resource.

    For example, to create a concrete view binding the 'GET' and 'POST' methods
    to the 'list' and 'create' actions...

    view = MyViewSet.as_view({'get': 'list', 'post': 'create'})
    """

    @classonlymethod
    def as_view(cls, actions=None, **initkwargs):
        """
        Because of the way class based views create a closure around the
        instantiated view, we need to totally reimplement `.as_view`,
        and slightly modify the view function that is created and returned.
        """

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            # We also store the mapping of request methods to actions,
            # so that we can later set the action attribute.
            # eg. `self.action = 'list'` on an incoming GET request.
            self.action_map = actions

            # Bind methods to actions
            # This is the bit that's different to a standard view
            for method, action in actions.items():
                handler = getattr(self, action)
                setattr(self, method, handler)

            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get

            self.request = request
            self.args = args
            self.kwargs = kwargs

            # And continue as usual
            return self.dispatch(request, *args, **kwargs)

        # take name and docstring from class
        update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        update_wrapper(view, cls.dispatch, assigned=())

        # We need to set these on the view function, so that breadcrumb
        # generation can pick out these bits of information from a
        # resolved URL.
        view.cls = cls
        view.initkwargs = initkwargs
        view.suffix = initkwargs.get('suffix', None)
        view.actions = actions
        return csrf_exempt(view)

    def initialize_request(self, request, *args, **kwargs):
        """
        Set the `.action` attribute on the view,
        depending on the request method.
        """
        request = super(ViewSetMixin, self).initialize_request(request, *args, **kwargs)
        method = request.method.lower()
        if method == 'options':
            # This is a special case as we always provide handling for the
            # options method in the base `View` class.
            # Unlike the other explicitly defined actions, 'metadata' is implicit.
            self.action = 'metadata'
        else:
            self.action = self.action_map.get(method)
        return request
{% endcodeblock %}


#### rest_framework.viewsets.ReadOnlyModelViewSet

{% codeblock lang:python %}
"""
继承两个混合类
    - mixins.RetrieveModelMixin  提供retrieve()方法，实现详情视图
    - mixins.ListModelMixin     提供list()方法，实现列表视图
"""

class ReadOnlyModelViewSet(mixins.RetrieveModelMixin,
                           mixins.ListModelMixin,
                           GenericViewSet):
    """
    A viewset that provides default `list()` and `retrieve()` actions.
    """
    pass
{% endcodeblock %}

#### rest_framework.viewsets.ModelViewSet

{% codeblock lang:python %}
"""
继承五个混合类
    - mixins.CreateModelMixin   提供create()方法，实现创建对象视图
    - mixins.RetrieveModelMixin  提供retrieve()方法，实现对象详情视图
    - mixins.ListModelMixin     提供list()方法，实现列表视图
    - mixins.UpdateModelMixin   提供update()方法，实现更新对象视图
    - mixins.DestroyModelMixin  提供destroy()方法，实现删除对象视图
"""

class ModelViewSet(mixins.CreateModelMixin,
                   mixins.RetrieveModelMixin,
                   mixins.UpdateModelMixin,
                   mixins.DestroyModelMixin,
                   mixins.ListModelMixin,
                   GenericViewSet):
    """
    A viewset that provides default `create()`, `retrieve()`, `update()`,
    `partial_update()`, `destroy()` and `list()` actions.
    """
    pass
{% endcodeblock %}