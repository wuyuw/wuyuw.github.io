---
title: DRF最佳实践及源码解读(四)--版本控制
date: 2020-04-18 14:46:37
categories:
- [Python, Web]
tags:
    - Django
    - Python
    - Restful
---


{% img /images/djangorestframework.png    '"DRF框架"' %}

<!-- more -->

## DRF支持queryparams、urlpath等多种方式的路由版本控制

### 1.原理
{% codeblock lang:python %}
"""
1.在请求分发前的初始化处理中引入版本控制
2.通过versioning_class获取具体的版本控制类
3.将获取到的版本version及版本控制对象versioning_scheme赋值给request
"""

class APIView(View):
    versioning_class = api_settings.DEFAULT_VERSIONING_CLASS

    def initial(self, request, *args, **kwargs):
        """
        Runs anything that needs to occur prior to calling the method handler.
        """
        self.format_kwarg = self.get_format_suffix(**kwargs)

        # Perform content negotiation and store the accepted info on the request
        neg = self.perform_content_negotiation(request)
        request.accepted_renderer, request.accepted_media_type = neg

        # Determine the API version, if versioning is in use.
        version, scheme = self.determine_version(request, *args, **kwargs)
        request.version, request.versioning_scheme = version, scheme

        # Ensure that the incoming request is permitted
        self.perform_authentication(request)
        self.check_permissions(request)
        self.check_throttles(request)
    
    def determine_version(self, request, *args, **kwargs):
        """
        If versioning is being used, then determine any API version for the
        incoming request. Returns a two-tuple of (version, versioning_scheme)
        """
        if self.versioning_class is None:
            return (None, None)
        scheme = self.versioning_class()
        return (scheme.determine_version(request, *args, **kwargs), scheme)


{% endcodeblock %}

### 2.用法

{% codeblock lang:python %}
"""
最常用的是urlpath中进行版本控制

1.全局配置
REST_FRAMEWORK = {
    # 版本控制类
    "DEFAULT_VERSIONING_CLASS": "rest_framework.versioning.URLPathVersioning",
    # 默认版本
    "DEFAULT_VERSION": "v1",
    # 允许的版本
    "ALLOWED_VERSIONS": ["v1", "v2"],
    # 版本参数名
    "VERSION_PARAM": "version"
}

2.路由系统
urlpatterns = [
    url(r'^(?P<version>[v1|v2]+)/users/$', views.UserView.as_view(), name='user'),
]

3.视图使用

class UserView(APIView):
    def get(self, request, *args, **kwargs):
        # 获取版本
        version = request.version
        # 获取版本控制对象
        version_schema = request.versioning_schema
        # 反向生成url
        u1 = request.versioning_schema.reverse(viewname='user', request=request)

"""


class URLPathVersioning(BaseVersioning):
    """
    To the client this is the same style as `NamespaceVersioning`.
    The difference is in the backend - this implementation uses
    Django's URL keyword arguments to determine the version.

    An example URL conf for two views that accept two different versions.

    urlpatterns = [
        url(r'^(?P<version>[v1|v2]+)/users/$', users_list, name='users-list'),
        url(r'^(?P<version>[v1|v2]+)/users/(?P<pk>[0-9]+)/$', users_detail, name='users-detail')
    ]

    GET /1.0/something/ HTTP/1.1
    Host: example.com
    Accept: application/json
    """
    
    default_version = api_settings.DEFAULT_VERSION
    allowed_versions = api_settings.ALLOWED_VERSIONS
    version_param = api_settings.VERSION_PARAM
    invalid_version_message = _('Invalid version in URL path.')

    def determine_version(self, request, *args, **kwargs):
        version = kwargs.get(self.version_param, self.default_version)
        if not self.is_allowed_version(version):
            raise exceptions.NotFound(self.invalid_version_message)
        return version

    def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra):
        if request.version is not None:
            kwargs = {} if (kwargs is None) else kwargs
            kwargs[self.version_param] = request.version

        return super(URLPathVersioning, self).reverse(
            viewname, args, kwargs, request, format, **extra
        )


{% endcodeblock %}